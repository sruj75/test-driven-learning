---
description: 
globs: 
alwaysApply: false
---
# UI Component Structure

This project follows a frontend-first approach with modular UI components. Below is the recommended component organization.

## Component Organization

```
/components
  /common            # Reusable UI components
    Button.tsx
    Card.tsx
    Input.tsx
    Modal.tsx
  /layout            # Layout components
    Header.tsx
    Footer.tsx
    Sidebar.tsx
    PageContainer.tsx
  /auth              # Authentication components
    LoginForm.tsx
    SignupForm.tsx
    UserProfile.tsx
  /tests             # Test-taking components
    QuestionCard.tsx
    AnswerOptions.tsx
    TestProgress.tsx
    ResultsSummary.tsx
  /learning          # Learning recommendation components
    VideoCard.tsx
    ResourceList.tsx
    LearningPath.tsx
  /dashboard         # Dashboard components
    ProgressChart.tsx
    ActivitySummary.tsx
    GoalTracker.tsx
```

## Component Design Principles

1. **Modular & Reusable**: Components should be self-contained with clearly defined props
2. **Progressive Enhancement**: Start with basic functionality, then enhance with backend integration
3. **Responsive Design**: All components should work across devices (mobile-first approach)
4. **Accessibility**: Follow WCAG guidelines for accessible UI elements
5. **State Management**: Use local state first, then Context API for shared state

## Component Implementation Phases

### Phase 1: Basic UI Elements
- Implement core UI components with static data
- Focus on design system consistency
- Establish responsive layouts

### Phase 2: Interactive Frontend
- Add state management to components
- Implement user interactions
- Create mock data handlers

### Phase 3: Backend Integration
- Connect components to Supabase
- Implement real data fetching
- Add loading and error states

## Styling Approach

Use TailwindCSS for styling with consistent design tokens:

```tsx
// Example component with TailwindCSS
const Button = ({ children, variant = 'primary' }) => {
  const variantClasses = {
    primary: 'bg-blue-600 hover:bg-blue-700 text-white',
    secondary: 'bg-gray-200 hover:bg-gray-300 text-gray-800',
    danger: 'bg-red-600 hover:bg-red-700 text-white',
  };
  
  return (
    <button 
      className={`px-4 py-2 rounded-md font-medium transition-colors ${variantClasses[variant]}`}
    >
      {children}
    </button>
  );
};
```

## Forms and Validation

For forms, start with basic HTML validation, then enhance with client-side validation using React state before adding backend validation.
